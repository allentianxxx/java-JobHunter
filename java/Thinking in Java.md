# Thinking in Java

## 第1章 对象导论

### 抽象

“命令式”语言要求程序员建立 「解空间」（对问题建模处，计算机） 和「问题空间」（问题存在处，一项业务）的联系

OOP允许根据问题来描述问题，而不是根据运行解决方案的计算机来描述问题

对象具有状态、行为、标识

### 访问控制

public：所有人

private：类创建者和内部方法

protected：可以被子类访问的private

默认：包访问权限

### 继承

允许“声明多继承”，不允许“实现多继承”

只继承不做任何操作，那么子类和父类完全一样的行为和类型，没什么意义

### 多态

编译器默认**后期绑定**：编译时不确定要运行代码，只确保被调用方法存在，进行参数和返回值类型检查，运行时才根据实际类型执行对应方法（出现于父类形参，传入子类实参） 。将子类看作父类的行为：upcasting（向上转型）

### 容器

也称为集合，Java有各种类型不同容器主要是因为 **1.提供了不同类型接口和外部行为 2.对某些操作的不同效率**

如具有相同类型接口和外部行为的 ArrayList（适合随机访问）LinkedList（适合随机插入）

#### 参数化类型（范型）

Java 5 加入的，避免了容器在存储对象过程中的向上转型（变为Object）和取出时的向下转型（耗时且可能引发异常）

### 对象创建和生命周期

C语言为追求效率，必须显示指定对象存储空间、类型，对象存储在**堆栈**（**创建释放快**，但不灵活，必须知道存储在堆栈中数据确切生命周期，以便上下移动堆栈指针），编译器知道对象生命周期，**通过编程来确定何时销毁对象**

####完全采用动态内存分配

Java在运行时才知道，且在运行时在**堆（heap**）内为对象动态分配内存，通过**垃圾回收器**自动清理不使用的对象（得益于单根继承的特性）

**Java对象存储在堆，但对象引用和基本数据类型存储在堆栈**

### 异常处理不是面向对象独有特性

### 并发编程

Java的多线程指的是语言级别的，逻辑上的多线程，**虚拟机中的线程状态，不反映任何操作系统线程状态**

JDK 1.2 以前对操作系统来说是 用户级线程ULT（UserLevelThreads），操作系统认为还是只有一个Java进程

JDK1.2及以后通过系统调用，将程序的线程交给了操作系统内核进行调度，**现在的Java中线程的本质，其实就是操作系统中的线程**

CPU是工厂，车间是进程，车间里的工人是线程，车间里的厕所可以理解为共享内存

## 第二章 一切都是对象（但基本数据类型不是对象）

String s是对象引用，对象引用是遥控器，对象是电视机

### 存储

**寄存器：**在Java语言中不能进行操作 

**堆栈：**存在RAM中，是部分Java数据存储的地方——包括**对象引用**和**基本类型**

**堆（通用内存池）：**存在RAM中，存放Java对象（**相较于堆栈的好处**：编译器不需要知道存储数据的生命周期）

**常量存储：**存放在代码内部

**非RAM存储（程序结束后仍保持自己状态）：**流对象（字节流，发送给另一台机器）持久化对象（存放在磁盘）

### 作用域

变量（如对象引用）只作用于作用域结束之前

```java
{
    int x = 12;
    {
        int x = 12; //Illegal in Java, but legal in C/C++(“隐藏”较大作用域的变量)
    }
}
```

**但对象可以存活于作用域之外（只要需要用到的话）**

```java
{
    String s = new String("a String");
}//End of scope 作用域结束时，对象引用 s 消失，但对象还继续占用着内存空间
```

### 基本成员默认值

基本类型用作**类的成员**时会有默认值boolean=false，char='\u0000'，剩余数值类型默认值都为0

char的默认值 '\u0000' 是 Unicode 中的空字符。 **和Java中的 null 引用不是一个东西**

| 基本类型 |  默认值  |
| :------: | :------: |
| boolean  |  false   |
|   char   | '\u0000' |
|   byte   | (byte)0  |
|  short   | (short)0 |
|   int    |    0     |
|   long   |    0L    |
|  float   |   0.0f   |
|  double  |   0.0d   |



## 第三章 操作符

### 使用

**=，==，!=，可以操作所有对象，其他操作符只能操作基本类型**

**副作用**：赋值操作=，自动递增、递减 ++，-- 。操作符改变了操作数自身的值（一般操作符是用于操作数生成一个新值）

### 赋值

a=b，给对象赋值传递的是**对象引用**（**别名现象**：复制了一份b给a，此时<u>对象引用a和b同时指向b所指向的对象</u>，a引用被覆盖，其原本指向的对象会交给垃圾回收器处理）

给基本类型赋值就是直接复制了数值

### 算术操作符

+、-、*、/、%

操作符紧跟一个等号 +=，-=，此中形式适用于Java所有「二元」操作符，只要有实际意义即可

### 一元加、减操作符

一元减号用于转换数据符号

一元加号只是为了对应一元减号（**但唯一作用是把较小类型的操作数提升为int**）

```java
byte b = 1;
byte c = +b; // 会报错
int d = +b; // 正常运行
```

### 自动递增递减

++、--

### 关系操作符

<、>、<=、>=、==、!=

### 逻辑操作符

&&、||、!

### 短路

&&逻辑表达式产生了false值，后面部分都不进行计算

||逻辑表达式产生了true值，后面部分都不进行计算

### 直接常量

```java
int i = 0x2f; //16进制
int i2 = 0177; //8进制
```

### 指数计数法

e代表的不是我们常理解的自然对数的基数

从FORTRAN开始，到C/C++和Java延续了下来，e代表的是10

```java
float f4 = 1e-43f;
```

编译器默认将指数当作double处理，这里如果不加f就会报类型的错

### 按位操作符（按位执行布尔代数运算）

二元：&、|、^、

一元：~（按位“非”，取反）

**布尔值特殊情况**：**按位操作符和逻辑操作符同样的效果，但不会短路（即&产生了false还会计算后面部分）**！！！

###移位操作符

<<左移：低位补0

\>>带符号右移：高位补符号位

\>>>无符号右移：高位补0（C/C++都没有）

也可以加=号，a<<=b，a左移b次，最后值赋给a

**对char byte short移位时，会先转换为int再移位，对它们进行算术运算时也是一样**

### 类型转换

除布尔型之外的基本数据类型都可以进行强制类型转换

## 第四章 控制执行流程

### continue、break的label使用

label：和goto一个意思

continue label，跳转到label，但继续执行循环

break label，跳转到label，不执行循环

使用场景：嵌套循环想要从多层嵌套中break或continue

### switch语句

选择因子必须是整数值 （integral-selector）,如果是字符串或者浮点数，则必须用if-else

**但Java 5 的 enum削弱了这种限制**

## 第五章 初始化与清理（cleanup）

### 构造器

没有返回值，和void返回值都不同，就是没有

new 表达式倒是返回了一个对新建对象的引用

### 方法重载（overloading）

方法名相同，区分通过：参数类型列表

### this关键字（本质就是一个对象引用）

只出现在非static方法内部，对象引用，指向调用方法的那个对象

使用场景：将自身传递给外部方法、构造器中调用构造器

### finalize()：执行特殊清理工作

**使用场景：**

- 用于清理一种被特殊分配内存的对象，即调用非java代码分配了内存的对象
- 用于在验证程序终结条件，是否有未被清理的地方

在垃圾回收发生时，会首先调用对象finalize()方法，并在下一次垃圾回收时才真正收回此对象占用内存

**注意：**

1. 对象可能不被垃圾回收（**垃圾回收并不是一定发生的**）
2. 垃圾回收不等于“析构（C/C++）”
3. 垃圾回收只和内存相关

### JIT（just in time）

热点代码检测，JIT判断字节码中哪些是频繁执行的，编译成机器码。如果是用的很少，就解释执行

![](https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/img001.png)

**编译 Compile**：把整个程序源代码翻译成另外一种代码，然后等待被执行，发生在运行之前，产物是「另一份代码」。
**解释 Interpret**：把程序源代码一行一行的读懂然后执行，发生在运行时，产物是「运行结果」。

### 数组初始化

**1.基本数据类型数组**

int[] a = {};

int[] a = new int[n]; 运行时创建，**这时数组元素若是基本类型会自动初始化默认值**

**2.对象数组（本质上是一个引用数组）**

Integer[] a = {new Integer(1), new Integer(2), 3, };

Integer[] a = new Integer[]{new Integer(1), new Integer(2), 3, };

### 可变参数列表Varargs（Java 5添加）

**只能对最后一个形参使用**

**使用场景：**在不确定方法需要处理的对象的数量时可以使用可变长参数，会使得方法调用更简单，无需手动创建数组 new T[]{…}

**调用方式：**

```java
public class Varargs {
    public static void test(String... args) {
        for(String arg : args) {
            System.out.println(arg);
        }
    }
    public static void main(String[] args) {
        test();//0个参数
        test("a");//1个参数
        test("a","b");//多个参数
        test(new String[] {"a", "b", "c"});//直接传递数组
    }
}
```

### 枚举enum（Java 5添加）

对象是有限且固定的类，其地位与 class、interface 相同；

枚举类是一种特殊的类，有自己的成员变量、成员方法、构造器 (只能使用 **private** 访问修饰符，**构造器只在构造枚举值时被调用**)；

使用 enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口;

所有的**枚举值都是 public static final** 的，且非抽象的枚举类不能再派生子类；

枚举类的所有实例(枚举值)**必须在枚举类的第一行显式地列出**，否则这个枚举类将永远不能产生实例

```java
public enum WeekEnum {
    // 因为已经定义了带参数的构造器，所以在列出枚举值时必须传入对应的参数
    SUNDAY("星期日"), MONDAY("星期一"), TUESDAY("星期二"), WEDNESDAY("星期三"),
    THURSDAY("星期四"), FRIDAY("星期五"), SATURDAY("星期六");
    // 定义一个 private 修饰的实例变量
    private String date;
    // 定义一个带参数的构造器，枚举类的构造器只能使用 private 修饰
    private WeekEnum(String date) {
        this.date = date;
    }
    // 定义 get set 方法
    public String getDate() {
        return date;
    }
    public void setDate(String date) {
        this.date = date;
    }
}
```

**枚举类对象两个默认的字段：name:String和ordinal:int**，分别存放枚举值、枚举值对应的int（0开始）

枚举类的每个枚举值就是该枚举类的一个对象

**和其他非抽象类不同，枚举类可以定义抽象方法，但其所有枚举值必须实现该方法**

```java
public enum Operation {
    // 用于执行加法运算
    PLUS { // 花括号部分其实是一个匿名内部子类
        @Override
        public double calculate(double x, double y) {
            return x + y;
        }
    },
    // 用于执行减法运算
    MINUS { // 花括号部分其实是一个匿名内部子类
        @Override
        public double calculate(double x, double y) {
            // TODO Auto-generated method stub
            return x - y;
        }
    },
    // 用于执行乘法运算
    TIMES { // 花括号部分其实是一个匿名内部子类
        @Override
        public double calculate(double x, double y) {
            return x * y;
        }
    },
    // 用于执行除法运算
    DIVIDE { // 花括号部分其实是一个匿名内部子类
        @Override
        public double calculate(double x, double y) {
            return x / y;
        }
    };
    //为该枚举类定义一个抽象方法，枚举类中所有的枚举值都必须实现这个方法
    public abstract double calculate(double x, double y);

}
```

## 第六章 访问权限控制

public：所有人

private：类创建者和内部方法

protected：修饰的成员对于本包和其子类可见

- 基类的protected成员是包内可见的，并且对子类可见；
- 若子类与基类不在同一包中，那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。

默认：包访问权限（有时也表示成friendly）

```
            │ Class │ Package │ Subclass │ Subclass │ World
            │       │         │(same pkg)│(diff pkg)│ 
────────────┼───────┼─────────┼──────────┼──────────┼────────
public      │   +   │    +    │    +     │     +    │   +     
────────────┼───────┼─────────┼──────────┼──────────┼────────
protected   │   +   │    +    │    +     │     +    │         
────────────┼───────┼─────────┼──────────┼──────────┼────────
no modifier │   +   │    +    │    +     │          │    
────────────┼───────┼─────────┼──────────┼──────────┼────────
private     │   +   │         │          │          │    

 + : accessible         blank : not accessible
```

### 类访问权限

如果不加默认是包访问权限：只有同一包下的类可以创建该类对象，但如果此类有一个public static的字段，则包外的类仍可以使用此字段

## 第七章 复用类

**相比于继承，我们更优先使用组合**

###组合

类字段里包含其他类的对象引用（显示的用到其他类的行为）

###继承

子类对象里都有一个隐藏的基类对象：初始化子类之前必须初始化基类（隐式的用到其他类的行为）

### 代理

主要作用，还是在不修改被代理对象的源码上，进行功能的增强。这在 AOP 面向切面编程领域经常见。

https://blog.csdn.net/briblue/article/details/73928350

### final关键字

**编译器常量**：staic和final同时修饰的基本数据类型，定义时必须赋值

final可以用来修饰对象引用，但是这个意义仅在于对象引用只能永远指向这个对象，**但对象本身仍然可以被更改**

**final字段必须在定义时赋值，或者是在构造函数中赋值**

**final方法**：为了防止被子类覆盖，**private方法隐含就是final方法**

**final类**：禁止继承，其所有方法都默认是final方法

### 类的加载

**类是在其任何static成员第一次被访问时加载的，构造函数也是（static）**

**静态代码块：**用staitc声明，jvm加载类时执行，仅执行一次
**构造代码块：**类中直接用{}定义，每一次创建对象时执行。
**执行顺序优先级：**静态块 > main() > 实例变量初始化 > 构造代码块 > 构造函数

其实实际上 实例变量初始化和构造代码块（实例代码块） 实际上是放在构造函数的超类构造函数之后，本类构造代码之前

## 第八章 多态（又名动态或后期或运行时绑定）

**绑定**：将方法的调用和方法主体关联起来

**前期绑定**：在程序执行前绑定（面向过程语言默认）

**后期绑定**：运行时根据对象的类型进行绑定

**向上转型的使用场景**：在要求基类对象的地方，传入子类方法，这样就不用为每一个子类都单独写一个实现的方法（**多态去耦合**）

**Java中除类static和final方法（private属于final方法）之外，其他方法都是后期绑定**

**协变返回类型**：子类重写的基类方法可以返回基类方法返回类型的子类类型

### 纯粹继承与扩展

**纯粹继承（is-a关系）**：导出类只覆盖基类已有的方法，导出类和基类之间可以相互替换

**扩展（is-like-a关系）**：导出类有额外的新方法，向上转型后这些方法就无法调用

**向下转型是不安全的**：**java对所有转型都会进行检查**

**状态模式(State Pattern)**。利用多态，状态模式可以在runtime改变内部组件的类型，从而完全改变类的行为，因此比继承更灵活。

**继承来表现行为间的差异，字段来表现状态上的变化**

## 第九章 接口

**优先使用类而不是接口**

**接口和内部类提供了一种将接口和实现分离的更加结构化的方法**

### 抽象类（类和接口的折中）

**有抽象方法的类是抽象类，抽象类不一定有抽象方法**（禁止一个类创建对象，但它又不需要抽象方法）

```java
abstract void f();//抽象方法没有方法体
```

**继承抽象类的导出类必须实现所有抽象方法，否则其本身也需要加上abstract关键字，成为抽象类**

相比于接口，抽象类还可以有具体实现

### 接口

**完全抽象的类**

**使用接口的核心原因**：为了能够向上转型为多个基类型（以及由此带来的灵活性）

**接口的域**：**默认就是public static final**

**接口方法**：**默认就是public abstract的**

**接口没有构造器**

接口的多态性是指实现接口的类重写接口的抽象方法

接口可以通过extends接口来扩展接口

接口最常用场景：**策略设计模式**，体现在，一个方法提供一个接口类型的参数，让调用者传入有接口具体实现的类的对象，即不同类型的对象来得到了不同的实现。

jdk 1.5之前（没有enum关键字），接口被用来创建常量组

**接口可以嵌套在类或接口里**：但实现接口时，不需要实现其内部嵌套的接口。且private接口只能在其定义类里被实现

**接口与工厂**：https://www.zhihu.com/question/30351872

## 第十章 内部类（不同于组合）

### 普通内部类

**自动拥有一个指向外部类对象的引用**

要从外部类的非静态方法创建内部类对象，则需要使用OuterClass.InnerClass

**不能有static成员**

**内部类具有外部类所有元素的访问权**

**内部类应用其外部类的对象**:**OuterClass.this**

**直接创建内部类对象**(**.new**)：先创建一个外部类对象 outer ，OuterClass.InnerClass inner = outer.new InnerClass();

**静态内部类（嵌套类）其实就相当于成为了一个顶级类**

### private 内部类

完全阻止依赖于类型的编码、隐藏了实现细节、无法访问不属于公共接口的方法

**内部类向上转型**：内部类实现了一个外部接口，但调用者访问其外部类提供的方法，得到一个内部类提供的向上转型的接口类型的引用，隐藏了实现细节

### 方法和任意作用域里的内部类

**为什么需要？**

- 实现接口，创建并返回对其的引用
- 创建类，不希望其公共可用

作用域和普通变量一样

### 匿名内部类

**说明：**返回值的生成，与表示这个返回值的类的定义结合在一起

通过new表达式返回的引用自动向上转型

只能访问外部final对象

**特点：1.扩展or实现接口，只能做一样 2.只能实现一个接口**

**工厂方法：**不必再单独实现一个具体的工厂类，直接在不同类型的实现类里定义一个工厂类型的static字段即可，直接用匿名内部类来给这个字段返回具体的工厂对象

###嵌套类（静态内部类）

**特点：**

- 创建嵌套类对象时，不需要外部类对象.new
- 嵌套类不能访问外部类非静态成员
- 可以有static成员

**用途：**

- 接口嵌套类，**成为接口的一部分**。用于创建公共代码，供接口的不同实现共同使用
- 嵌套类用做测试类，写测试代码

### 为什么需要内部类

内部类对象：访问外围类所有成员

内部类：进入外围类的窗口

**最吸引人的原因：**每个内部类可以单独实现一个接口，而不需要关心外部类是否实现了该接口

**多重继承**：内部类使得外部类实现了继承多个非接口类型（类和抽象类），因为接口本身就允许多继承

多个内部类可以有同一个接口的不同实现

内部类没有is-a关系的困扰，是一个独立实体

**闭包与回调：**闭包是一个可调用对象，记录了来自于创建它的作用域的信息，内部类是面向对象的闭包

回调：对象携带信息，在某一时刻调用初始对象



