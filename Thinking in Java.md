# Thinking in Java

## 第1章 对象导论

### 抽象

“命令式”语言要求程序员建立 「解空间」（对问题建模处，计算机） 和「问题空间」（问题存在处，一项业务）的联系

OOP允许根据问题来描述问题，而不是根据运行解决方案的计算机来描述问题

对象具有状态、行为、标识

### 访问控制

public：所有人

private：类创建者和内部方法

protected：可以被子类访问的private

默认：包访问权限

### 继承

允许“声明多继承”，不允许“实现多继承”

只继承不做任何操作，那么子类和父类完全一样的行为和类型，没什么意义

### 多态

编译器默认后期绑定：编译时不确定要运行代码，只确保被调用方法存在，进行参数和返回值类型检查，运行时才根据实际类型执行对应方法（出现于父类形参，传入子类实参） 。将子类看作父类的行为：upcasting（向上转型）

### 容器

也称为集合，Java有各种类型不同容器主要是因为 **1.提供了不同类型接口和外部行为 2.对某些操作的不同效率**

如具有相同类型接口和外部行为的 ArrayList（适合随机访问）LinkedList（适合随机插入）

#### 参数化类型（范型）

Java 5 加入的，避免了容器在存储对象过程中的向上转型（变为Object）和取出时的向下转型（耗时且可能引发异常）

### 对象创建和生命周期

C语言为追求效率，必须显示指定对象存储空间、类型，对象存储在**堆栈**（**创建释放快**，但不灵活，必须知道存储在堆栈中数据确切生命周期，以便上下移动堆栈指针），编译器知道对象生命周期，**通过编程来确定何时销毁对象**

####完全采用动态内存分配

Java在运行时才知道，且在运行时在**堆（heap**）内为对象动态分配内存，通过**垃圾回收器**自动清理不使用的对象（得益于单根继承的特性）

**Java对象存储在堆，但对象引用和基本数据类型存储在堆栈**

### 异常处理不是面向对象独有特性

### 并发编程

Java的多线程指的是语言级别的，逻辑上的多线程，**虚拟机中的线程状态，不反映任何操作系统线程状态**

JDK 1.2 以前对操作系统来说是 用户级线程ULT（UserLevelThreads），操作系统认为还是只有一个Java进程

JDK1.2及以后通过系统调用，将程序的线程交给了操作系统内核进行调度，**现在的Java中线程的本质，其实就是操作系统中的线程**

CPU是工厂，车间是进程，车间里的工人是线程，车间里的厕所可以理解为共享内存

## 第二章 一切都是对象（但基本数据类型不是对象）

String s是对象引用，对象引用是遥控器，对象是电视机

### 存储

**寄存器：**在Java语言中不能进行操作 

**堆栈：**存在RAM中，是部分Java数据存储的地方——包括**对象引用**和**基本类型**

**堆（通用内存池）：**存在RAM中，存放Java对象（**相较于堆栈的好处**：编译器不需要知道存储数据的生命周期）

**常量存储：**存放在代码内部

**非RAM存储（程序结束后仍保持自己状态）：**流对象（字节流，发送给另一台机器）持久化对象（存放在磁盘）

### 作用域

变量（如对象引用）只作用于作用域结束之前

```java
{
    int x = 12;
    {
        int x = 12; //Illegal in Java, but legal in C/C++(“隐藏”较大作用域的变量)
    }
}
```

**但对象可以存活于作用域之外（只要需要用到的话）**

```java
{
    String s = new String("a String");
}//End of scope 作用域结束时，对象引用 s 消失，但对象还继续占用着内存空间
```

### 基本成员默认值

基本类型用作**类的成员**时会有默认值boolean=false，char='\u0000'，剩余数值类型默认值都为0

char的默认值 '\u0000' 是 Unicode 中的空字符。 **和Java中的 null 引用不是一个东西**

| 基本类型 |  默认值  |
| :------: | :------: |
| boolean  |  false   |
|   char   | '\u0000' |
|   byte   | (byte)0  |
|  short   | (short)0 |
|   int    |    0     |
|   long   |    0L    |
|  float   |   0.0f   |
|  double  |   0.0d   |



## 第三章 操作符

### 使用

**=，==，!=，可以操作所有对象，其他操作符只能操作基本类型**

**副作用**：赋值操作=，自动递增、递减 ++，-- 。操作符改变了操作数自身的值（一般操作符是用于操作数生成一个新值）

### 赋值

a=b，给对象赋值传递的是**对象引用**（**别名现象**：复制了一份b给a，此时<u>对象引用a和b同时指向b所指向的对象</u>，a引用被覆盖，其原本指向的对象会交给垃圾回收器处理）

给基本类型赋值就是直接复制了数值

### 算术操作符

+、-、*、/、%

操作符紧跟一个等号 +=，-=，此中形式适用于Java所有「二元」操作符，只要有实际意义即可

### 一元加、减操作符

一元减号用于转换数据符号

一元加号知识为了对应一元减号（**但唯一作用是把较小类型的操作数提升为int**）

```java
byte b = 1;
byte c = +b; // 会报错
int d = +b; // 正常运行
```

### 自动递增递减

++、--

### 关系操作符

<、>、<=、>=、==、!=

### 逻辑操作符

&&、||、!

### 短路

&&逻辑表达式产生了false值，后面部分都不进行计算

||逻辑表达式产生了true值，后面部分都不进行计算

### 直接常量

```java
int i = 0x2f; //16进制
int i2 = 0177; //8进制
```

### 指数计数法

e代表的不是我们常理解的自然对数的基数

从FORTRAN开始，到C/C++和Java延续了下来，e代表的是10

```java
float f4 = 1e-43f;
```

编译器默认将指数当作double处理，这里如果不加f就会报类型的错

### 按位操作符（按位执行布尔代数运算）

二元：&、|、^、

一元：~（按位“非”，取反）

**布尔值特殊情况**：**按位操作符和逻辑操作符同样的效果，并且不会短路**！！！



